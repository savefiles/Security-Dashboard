// REFACTORING NOTES
// Data will have to be reorganized. The data sent to the server NEEDS to be seperated by date.
// 
// New code logic:
// Query each day individually, keep them as seperate arrays.
// This gets stored on server, and client will parse them when displaying graph.
// After client parses, it gets stored in local storage with date, and if either day changes or it's been 2 hours, refresh.

// Class for keeping data from a date (not neccesary for good coding, but project requirement)
class CVEDayData {
    constructor(ISODate, data) {
        this.ISODate = ISODate;
        this.data = data;
    }
    getJSON() {
        return {
            date: this.ISODate,
            data: this.data
        }
    }
    toString() {
        return JSON.stringify(this.getJSON());
    }
}


// Based on the search terms, display relevant results. Added a numbers bar on the bottom to get through the pages.
// The old pages data gets stored to localstorage, and cleared when they leave the modal.
// INPUT: Search term
// OUTPUT: Possible related CVE's, or if they searched CVE, info on it.
export async function searchCVEDatabase(searchTerm, offset = 0) {
    let regexCVE = /^CVE-\d{4}-\d{4,}$/;
    let linkToFetch = `https://services.nvd.nist.gov/rest/json`
    let resultsPerPage = 10;
    let json;
    let htmlComponents = "";
    // If it's a CVE that is searched, display information.
    if(regexCVE.test(searchTerm)) {
        linkToFetch += `/cve/1.0/${searchTerm}`;
        json = await fetchCVEData(linkToFetch);

    }
    // It's a keyword.
    else {
        linkToFetch += `/cves/1.0?keyword=${searchTerm}&resultsPerPage=${resultsPerPage}&startIndex=${offset}`;
        json = await fetchCVEData(linkToFetch);
    }

    if(json == 404) return "<b>No results found.</b>";
    if(json == 504) return "<b>API is down. Please try again later.</b>";

    // Display
    let totalNumResults = json.totalResults;
    let cves = json.result.CVE_Items;
    cves.forEach(cve => {
        htmlComponents += `
        <h3>${cve.cve.CVE_data_meta.ID}</h3>
        <p>${cve.cve.description.description_data[0].value} </p>
        <p>Published on ${cve.publishedDate}. <a href='https://nvd.nist.gov/vuln/detail/${cve.cve.CVE_data_meta.ID}'>More info.</a></p>
        <hr>
        `;
    });

    // Tried making navigation buttons at the bottom, didn't work, and Vue is a pain in the ass.
    if(totalNumResults / resultsPerPage > 1) {
        htmlComponents += `<a href='https://nvd.nist.gov/vuln/search/results?form_type=Basic&results_type=overview&query=${searchTerm}&search_type=all'>View all</a>`
    }
    
    return htmlComponents;

    // Below is my attempt at making navigation buttons.
    // Logic: figure out number of buttons to add at the bottom for navigation, add to large HTML string.
    // This gets passed back to Vue, which actually handles the new queries.
    // Display up to five numbers, two in each direction. Current page should be center.

    //let numOfPages = Math.ceil(totalNumResults / resultsPerPage);
    //let currPage = Math.ceil(offset + 1 / resultsPerPage); // round up
    //
    //// Doing the styles through the .css file didn't work, so we inline.
    //htmlComponents += "<div id='modal-bottom-navigation' style='display: grid; grid-template-columns: [col-left] 1fr repeat(7, [col] 30px) [col-right] 1fr; justify-items: center;'>";
    //// Add all seven boxes, only display the proper ones.
    //if(currPage > 3) {
    //    htmlComponents += "<b-button class='modal-bottom-element' variant='link' v-on:click='searchoffset = 0; search();' style='grid-column-start: col 1'>...</b-button>"
    //}
    //for(let i = -2; i <= 2; i++) {  
    //    // If it should be displayed
    //    // Should display as button not text
    //    // v-on:click='searchoffset = ${10*(currPage+i)}; search();'
    //    if(clamp(currPage + i, 1, numOfPages) == currPage + i) {
    //        htmlComponents += `<button class='modal-bottom-element' v-on:click='searchoffset = ${currPage+i}; search(); console.log("hi")' style='grid-column-start: col ${i + 4}'>${currPage + i}</b-button>`
    //    }
    //}
    //if(currPage < numOfPages - 3) {
    //    htmlComponents += `<b-button class='modal-bottom-element' variant='link' v-on:click='searchoffset = ${numOfPages}; search();' style='grid-column-start: col 7'; search();'>...</b-button>`
    //}
    //htmlComponents += "</div>"
    //
    //// Return the search results, and properties needed to create bottom buttons.
    //return [htmlComponents, [currPage, numOfPages]];
}
// Helper function
//function clamp(numToClamp, min, max) {
//    return Math.max(Math.min(numToClamp, max), min);
//}

/* 
 *  SECTION FOR SEARCHING CVE FOR THE GRAPH
 *  very long so we have divider.
 */

// Get the data using the specified timestamps
// INPUT: dateArray should contain timestamps which represent days, and can be passed directly into Date object.
// (this means take PHP strtotime, and multiply by 1000 https://stackoverflow.com/questions/10837022/convert-php-date-into-javascript-date-format)
export async function getCVEData(dateArray) {

    console.log("Fetching new data for the graph...");
    let promises = [];
    // Get data from each day for the last month (which we consider to be 30 days)
    for(let i = 0; i < dateArray.length; i++) {
        let date = new Date(dateArray[i]);
        // Returns an object with timestamp and data.
        promises.push(getDataFromSpecifiedDate(date));
        // Sleep for 2 seconds between each one.
        await new Promise(r => setTimeout(r, 2000))
    }

    // Once all of the promises return.
    let requestedData = [];
    await Promise.all(promises).then((cveData) => {
        cveData.forEach(data => {
            let parsedData = {date: data.date, data: parseJSONIntoProducts(data.data)};
            requestedData.push(parsedData);
        });
    });
    await Promise.all(requestedData);

    return requestedData;
}




// Get the data from the specified day.
// INPUT: Date object.
async function getDataFromSpecifiedDate(date) {

    // Get the date in the format required by the API.
    let ISODate = date.toISOString();
    ISODate = ISODate.slice(0, -5) + ":" + ISODate.slice(-4, -1) +" UTC-00:00";

    // Get the date of the next day.
    let ISONextDate = new Date(date.setDate(date.getDate() + 1)).toISOString();
    ISONextDate = ISONextDate.slice(0, -5) + ":" + ISONextDate.slice(-4, -1) +" UTC-00:00";

    // Fetch the data, and parse (get 500 per page, which should be more than any one day).
    let linkToFetch = `https://services.nvd.nist.gov/rest/json/cves/1.0?pubStartDate=${ISODate}&pubEndDate=${ISONextDate}&resultsPerPage=500`;
    let CVEData = await fetchCVEData(linkToFetch);
    //let CVEData = await fetchAndParseAllCVEData();

    // Add to our ES6 Class.
    let DayData = new CVEDayData(new Date(date.setDate(date.getDate() - 1)).valueOf(), CVEData);
    return DayData.getJSON();
}

// INPUT: an array of previously parsed data.
// OUTPUT: combined arrays, ready to graph.
export async function combineParsedData(data) {

    // Returned data from the json parser
    let applicationList = {name: "Applications", children: []};
    let operatingSystemList = {name: "Operating Systems", children: []};
    let hardwareList = {name: "Hardware", children: []};

    // Function that properly appends the product to the given list.
    function appendToList(list, product) {
        let index = list.children.findIndex(e => e.name == product.name);
        if(index == -1) {
            list.children.push(product);
        }
        else {
            list.children[index].children.push(product.children);
        }
    }


    data.forEach(arrays => {
        // Make it into a promise (input will now always be promise)
        let arraysPromise = Promise.resolve(arrays);
        arraysPromise.then((lists) => {
            // Add each returned array to super array.
            lists[0].children.forEach(product => {
                appendToList(applicationList, product);
            });
            lists[1].children.forEach(product => {
                appendToList(operatingSystemList, product);
            });
            lists[2].children.forEach(product => {
                appendToList(hardwareList, product);
            });
        });
    });



    return [applicationList, operatingSystemList, hardwareList];
}

export function prepareForGraph(data) {
    
    // Convert any input data if it is not a promise into a promise (does not effect promises).
    data = Promise.resolve(data);

    // Final object to return, formatted for the fancy-bar-graph.
    let graph = {
        name: "Graph name",
        children: []
    };

    // Apparently can't directly access values from promises, need to use then even though they are fulfilled.
    data.then((value) => {
        let [applicationList, operatingSystemList, hardwareList] = value;


        graph.children.push(applicationList);
        graph.children.push(operatingSystemList);
        graph.children.push(hardwareList);
    });

    return graph;
}

// Get all of the application/operating systems affected by each CVE.
// INPUT: JSON
// OUTPUT: Three arrays containing application, os, and hardware cve lists.
async function parseJSONIntoProducts(json) {
    let cveList = await json.result.CVE_Items;
    // Returned data from the json parser
    let applicationList = {name: "Applications", children: []};
    let operatingSystemList = {name: "Operating Systems", children: []};
    let hardwareList = {name: "Hardware", children: []};

    // Function to add to a list, in a format that the fancy bar graph accepts.
    function addToList(list, product, cve_name) {
        // If the list doesn't contain this product, create new entry in list.
        let index = list.children.findIndex(e => e.name == product);
        if(index == -1) {
            index = -1 + list.children.push({
                name: product,
                children: []
            });
        }
        list.children[index].children.push({
            name: cve_name,
            value: 1
        });
    }

    // Takes in the CPE URI and adds it to the appropriate list.
    function addToAppropriateList(cpeURI, cve_name) {
        let regexCPEURI = /^cpe:2\.3:([^:]):([^:]+?):/;
        // Regex for the type and name ([1] is type, [2] is name).
        let matches = cpeURI.match(regexCPEURI);
        switch(matches[1]) {
            case "a":   // Application
                addToList(applicationList, matches[2], cve_name);
                break;
            case "o":   // OS
                addToList(operatingSystemList, matches[2], cve_name);
                break;
            case "h":   // Hardware
                addToList(hardwareList, matches[2], cve_name);
                break;
            default:    // Something broke
                console.log(cpeURI, cve_name);
                break;
        }
    }

    // Loop through all of the CVEs
    cveList.forEach(cve => {
        let name = cve.cve.CVE_data_meta.ID;
        let node = [ cve.configurations.nodes[0] ];
        // Failsafe.
        if(node[0] === undefined) return;

        // If there are children, perform operation on each child.
        //console.log(node);
        if(node[0].children.length != 0) {
            node = node[0].children; 
        }
        node.forEach(cpe => {
            let cpeURI = cpe.cpe_match[0].cpe23Uri;
            addToAppropriateList(cpeURI, name);
        });
    });

    return [applicationList, operatingSystemList, hardwareList];
}


// Get the json response of all of the CVEs given the link.
async function fetchCVEData(link) {
    const jsonCVE = await fetch(link)
                        .then(response => {
                            if(!response.ok){
                                return response.status;
                                //throw Error(`ERROR: ${response.statusText}`);
                            }
                            return response.json();
                        });
    return jsonCVE;
}